# 分布式锁
主要解决：在集群或者分布式的情况下，对同一个数据的操作，出现不一致的情况

常见的实现分布式锁的方法：
1.redis
2.zookeeper
3.myslq实现方案，使用数据库自身提供的锁机制

优缺点：
1.redis性能要比zookeeper高，但是redis有出现死锁的可能，不优雅
2.redis维护成本低，部署简单
3.zookeeper更能保证数据的高可用，比如zk单节点失效，他也会保留失效节点的数据，同步到从节点上，用于保证数据的一致性。这种要比redis集群通过红锁实现节点宕机导致的数据失效更好。

## Redis实现分布式锁
### 实现过程
通过设置setnx来设置分布式锁，该命令是值当前值不可覆盖，如果已经存在则返回false。
★设置锁时间：为了防止系统出现系统重启或者版本更换，导致的锁无法立即根据业务调整

★容易出现的问题：高并发的情况下。设置锁时间，如果锁时间的时长小于业务逻辑的执行时长
例如：当前线程（A）的锁已经设置并且超时，此时业务还没执行完，但是此时下一个线程（B）进来又重新设置一把锁。A线程执行完业务代码，把锁销毁，此时销毁的是B生成的锁，此时设置的锁时间是永远失效。

解决方法：
1.给当前线程设置一个唯一标识；
2.并且在加完锁之后设置一个定时器，去监测当前线程中的这个锁是否还存在，如果存在，则延时设置时间的1/3，用来保证当前锁在业务内的时效性(防止业务逻辑执行时间内，锁失效的问题)

★redis集群带来的问题
此时已经通过上述方法解决了问题，但是此时，如果是redis集群的情况下，redis主从节点，相互协调作业。
问题产生：当线程A对一个数据加锁，已经写入到redis主节点，但是此时redis主节点还没有将锁信息同步到redis从节点中就挂了，redis集群进行选举，从节点选为主节点。其他线程进来要使用这个数据，会从新上任的主节点中获取数据，结果没发现锁，所以会重新上锁。这样就导致了数据的丢失。
解决方法：
	
	
redis锁带来的性能问题：
解决办法：增加数据的细粒度，分块处理数据，对每一块数据都加上锁，每次处理一块数据

### 使用Redisson框架
~~~java
1.导入依赖包
<dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson</artifactId>
            <version>2.7.0</version>
        </dependency>
2.使用案例
    private static final String key = "key_";
    @Autowired
    private static Redisson redisson;
    public static void main(String[] args) {
        //获得锁对象
        RLock lock = redisson.getLock(key);
        try {
            //加锁并设置锁时间
            lock.lock(5, TimeUnit.SECONDS);
            System.out.println("执行业务代码~~~~");
        }finally {
            //释放锁
            lock.unlock();
        }
    }

底层代码分析：
    

~~~

## ZK实现分布式锁

### Zookeeper
zookeeper是一个开放源码的分布式协调服务，由雅虎公司创建，是chubby的开源实现。其设计目标是将那些复杂且容易出错的分布式一致型服务封装起来，并以一系列易用的接口提供给用户使用。
zookeeper的特性：
> 1.zookeeper会在内存中维护一个具有层次关系的数据结构，它非常类似于一个标准的文件系统；
> 2.数据节点(Znode)：数据结构中的每个节点都可以存数据，还有各种属性信息；数据节点由：持久节点，持久顺序节点，临时接待你以及临时顺序节点，临时顺序节点是实现分布式锁的基础。
> 3.时间监听器(Watcher)：客户端可以在节点注册watcher，当节点发生特定的变化，服务器会将事件通知到感兴趣的客户端。

持久节点：会在创建数据后，重启客户端不会消失，已经持久化到本地
临时节点：在创建数据后，重启客户端会消失
顺序就是：在对一个数据进行插入的时候，他会顺序递增

算法逻辑：
![](https://raw.githubusercontent.com/ClassIntreceptor/picgo_images /master/img/20200507230922.png)
分布式锁是临时顺序节点实现的。所以具有顺序性。
1.服务连接zk，对数据加锁，此时zk会创建一个临时顺序节点用来存储进入顺序，每个服务都有一个顺序key；
2.节点中的首节点（A）进入逻辑，如果为首节点，前面没人则此时会拿到锁，进入自己的业务计算；
3.此时B节点进入，发现由服务正在使用这个数据锁，它会创建一个监听器，用于监听A节点的状态，并且B节点进入阻塞状态
4.如果A节点执行完毕，B节点监听到，便会获得锁，进去自己的业务计算。


























