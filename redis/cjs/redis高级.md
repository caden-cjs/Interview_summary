# 缓存穿透
redis里面存放热门数据
通过redis最为mysql的数据缓存，服务端通过redis检测数据是否存在，如果存在则直接返回，不存在则通过mysql查询数据然后返回。

1.在高频率的请求一个数据库都没有的数据，必然会透过redis直达mysql进行获取。
场景1：高频通过id=-1请求服务器
解决方案：将这个查询的数据，放在redis缓存中，比如查 id=-1 返回值为null，此时就在redis中存放这条数据

场景2：高频通过id=uuid去请求服务器，按照场景1的解决方案会导致redis中大量的null值，并且会把热门数据给挤出去
解决方案：在redis与mysql中间，放置一个过滤器，这个过滤器中存放了mysql中的id值，当请求进来，经过redis没找到，然后经过过滤器，去过没找到这个id值，就会将请求返回。也就过滤掉了这个请求。

场景3：高频通过其他字段去访问，难道过滤器要放myql的所有数据么？这会导致过滤器中数据量很大
引入布隆算法：通过一定的错误率来降低内存的占用

布隆算法，会把数据通过算法扰动成一个数值，并存储在一个bit数组中，当进来两个值，他们的结算结果都是一致的并且，这个时候实际情况就是说明这个进来的值有可能不存在，如果告诉你该值不存在，那么这个数据一定不存在。

解决方案：
1.加上数据校验
2.加上布隆过滤器




## 雪崩
redis出现问题宕机或者异常导致其他服务不可用。
解决方案
1.集群模式
2.使用队列形式合理控制由于缓存失效造成的数据库压力巨大
3.让失效时间点均匀分布，就是设置失效时间不是一个固定值，让他在所定时间上前后随机几秒，通过这种时间的乱序解决

## 击穿

大量的并发访问某一个数据，而该数据刚好在访问的时刻超时了，就会导致大量的访问直接访问数据库上

解决方案：使用分布式锁，加队列

## 双写不一致
先删除缓存，然后写入库，写入库完毕之后，然后再写入缓存。

## redis的过期策略以及内存淘汰机制
定期删除+惰性删除
定期删除：规定一定时间，去随机删除redis中的部分失效的数据，会导致删除不完全
惰性删除：在获取key的时候，redis会检查一下，这个key如果设置过期时间，如果过期就会删除
但是这种组合删除也会问题，问题就是，使用定期删除没有删除key，然后使用惰性删除没有及时请求到这个key没有获取到，也会删除不成功，导致内存越来越高。后面就使用到了内存淘汰机制


allkeys-lru: 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。最常使用


